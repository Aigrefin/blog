= Le vrai coût du multi-tache pour les développeurs…
Julien Kirch
v1.0, 2014-01-13

(… n'est pas forcément celui qu'on présente partout)


Dans les présentation sur l'organisation des projets, lorsque'un animateur veut convaincre son auditoire des méfais du multi-tache pour les développeurs, on voit souvent une variation de ce slide:

image::graphe0.png[]

Par exemple link:http://availagility.co.uk/2008/10/28/kanban-flow-and-cadence/[ici], link:http://fr.slideshare.net/pawelbrodzinski/successful-evolutionary-change-of-portfolio-management[ici]  (slide 7), link:http://blog.codinghorror.com/the-multi-tasking-myth/[ici] ou link:http://www.infoq.com/articles/multitasking-problems[ici].

Ce graphique est très efficace:

- le graphique est frappant: on comprend immédiatement qu'il faut bannir complètement le multi-tâche
- la source donnée est un gage de sérieux: Gerald Weinberg est un nom connu, et le titre du livre (_Quality Software Management: Vol. 1 System Thinking_) impressionne.

Mais ce graphe a deux défauts :

- il est toujours présenté de la même manière : le même aspect avec la même manière de citer la source
- la manière dont les valeurs ont été déterminées les valeurs n'est jamais précisée

Cela laisse présager qu'on se trouve devant un anti-pattern classique: un même schéma est recopié par tout le monde, sans que personne ne consulte la source originale, surtout qu'ici le livre est ancien et n'existe pas sous forme électronique. Et ce qui arrive malheureusement souvent c'est que le schéma que tout le monde copie prend des liberté avec sa source footnote:[Lire link:https://leanpub.com/leprechauns[_The Leprechauns of Software Engineering_] de link:https://twitter.com/morendil[Laurent Bossavit] où il donne plusieurs exemples de ce pattern qui permettent ensuite de l'identifier facilement].

Bref il est temps d'enquêter. Le livre étant ancien link:http://www.amazon.com/exec/obidos/ASIN/0932633226[un peu de patience et quelques euros] permettent de se le procurer.

Dans le livre pas de trace du graphique. Au chapitre 17 l'auteur explique les dangers d’une gestion primaire des taches: un développeur sur deux tâches ça ne fait pas 50% d’un développeur sur chacune des taches mais moins.

En fin de chapitre, on trouve ce qu'on est venu chercher:

image::source.png[]

Dans une liste de tips il donne des chiffres comme aide à la planification. Ils permettent de savoir à peu près de combien il est possible de budgéter d'avancement sur les projets en fonction de leur nombre.

Les chiffres qu'il donnent sont sorti du chapeau, mais ils conviennent car ici seul l'ordre de grandeur est important. Par exemple si on passe la valeur de perte de 20% à 15% le tableau change peu, cette valeur conviendrait tout aussi bien pour le calcul d’avancement:

[cols="2*", options="header"]
|===
|Nombre de taches
|% du temps passé sur chaque tâche

|1
|100

|2
|42

|3
|23

|4
|14

|5
|8
|===

Donc avoir ces chiffres approximatif n’est pas un problème, pour _l'usage qu'en fait l'auteur_ d'un abaque pour calculer l'avancement des taches.

Quand on retourne au schéma de départ, on se rend compte que les valeurs présentées ne sont pas tout à fait les mêmes: au temps passé sur chaque tâche on a ajouté le temps perdu. Disposer de la source permet de se rendre compte que ce choix est très orienté: le graphie compare le temps passé _sur chaque tâche_ au temps perdu _en tout_.

Ainsi si on reprend le graphique original d'une manière un peu plus objective, voici ce qu'on obtient :

image::graphe1.png[]

L'impression n'est plus la même: travailler sur deux projets à la fois ne pose plus tellement de problème. Ma démonstration de départ ne tient plus.

Si on veut démonter le méchanisme jusqu'au bout, il faut se souvenir que dans le tableau original, seul l'ordre de valeur était important. Voici le graphique repris mais avec une perte de 15%:

image::graphe2.png[]

Ici travailler sur trois projets à la fois devient presque envisageable: la conclusion du graphique a changé alors que pour le besoin initial les deux séries de chiffres sont équivalentes.

La conclusion s'impose: en les utilisant dans un contexte différent de celui pour lequel ils ont été donnés, on veut faire dire à des chiffres quelque chose qu'il ne disent pas et la « démonstration » tombe à l'eau.

Si je suis convaincu que d'avoir plusieurs tâches en parallèle doit être évité, s'appuyer sur cette slide pour le justifier est donc une manipulation. La prochaine fois qu’on vous la présente vous serez vacciné.

Pour finir: s'il est un peu daté sur certains aspects, le livre de Weinberg a bien plus de valeur que l'usage détourné qui en est fait ici, je vous conseille de le parcourir.
